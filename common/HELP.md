# 公用的实体和工具模块

* 目前提供的实体
  * entity

# 常见的几种锁
* 阻塞锁 [BlockedLockTest.java](src/test/java/com/zhuzhe/common/BlockedLockTest.java)
* 非阻塞锁 [NonBlockingLockTest.java](src/test/java/com/zhuzhe/common/NonBlockingLockTest.java)
* JVM中对锁的判断 ![](img/JVM中记录锁的信息.jpg)
* 锁的状态 ![](img/锁的状态.png)
  > 无锁状态（Unlocked）

  当对象没有被任何线程锁定时处于无锁状态。
  
  > 有锁状态（Owned）

  当一个线程获得了对象的锁时，该对象处于被该线程拥有的状态。
  
  > 可偏向锁状态（Biased）

  概念：偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，偏向锁在资源无竞争的情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能

  引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量锁执行路径。因为轻量级锁的获取以及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）上面说过，轻量级锁是为了在多线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块的时候进一步提高性能。

  > 轻量级锁状态（Lightweight）

  “轻量级”是相对于使用操作系统互斥量来实现传统锁而言的。但是首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。当多个线程对同一个对象进行锁定竞争时，对象会从可偏向锁升级为轻量级锁。轻量级锁使用CAS（Compare and Swap）操作来实现锁的获取和释放，避免了传统的重量级锁的互斥操作，提高了性能。
  
  在解释轻量级锁的执行过程过程之前，我们要先明白一点，轻量级锁使用的场景是线程交替同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级。
  
  > 重量级锁（Heavyweight）

  synchronized是通过对象内部的一个监视器锁（monitor）实现的。但是monitor底层又依赖于底层操作系统的Mutex Lock实现的。而操作系统实现线程之间的切换就需要从用户态切换到核心态，切换的成本很高，状态之间的转化需要相对比较长的时间，这就是synchronized效率低的原因，因此，这种依赖于操作系统的Mutex Lock所实现的锁被称之为“重量级锁”。重量级锁使用操作系统的互斥量来实现锁的获取和释放，保证了线程的互斥访问。